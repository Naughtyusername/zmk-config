// SPDX-License-Identifier: MIT
#include "wrappers.dtsi" // qmk logic. has to come after the zmk headers
#define COMBO_TERM_FAST 18
#define COMBO_TERM_MED 30
#define COMBO_TERM_SLOW 50

/ {
    // clang-format off
    combos {
        compatible = "zmk,combos";
// =====================================================================================
/*
   // ===== UTILITY COMBOS (home row) =====
   // H + J = Caps Word
   // H + Y = NUM Word
   // J + K = Escape
   // L + ; = Enter
   // F + G = Underscore    _
   // S + D = Backspace
   // D + F = Tab
   // V + B = Minus         -
   // K + L = Single Quote  '
   // TODO we should add some more combos to home row, if we could do all of the
   common ones so we never have to leave uneless we want to do longeer sequences of
   symbols. i ended up using these way more than i initially thought i would,
   favorite feature that i slept on for years.

   \$|~&*=!+#^%@?

   + would be nice, * maybe.
   thoughts afer this week
   + * that way we have all the math symbols on the main layer
   we have keys as sd and df open, (i dont care about the backspace one i dont seem to use it
   i dont seem to care about tab either so we can change those most likely)
   then we have zx xc cv open as well. and then we have most the 3 finger combos open still and we also can do 2 hand combos

   so for a visual map keys we have open that we should fill this week
   as
   sd
   df
   zx
   xc
   cv

   logical same finger opposite hand combos, only issue is if we have to hold for the combo that kinda throws things off
   a;
   sl
   dk
   fj

   any other opposite hand combos id we do try them have to be non steno words/letters, otherwise misfires will happen
   and as it we arent misfiring hardly at all so no need to keep it that way

   open 3 finger combos
   zxc
   ert
   dfg
   cvb
   iop
   kl;
   ,./

   // ===== AUTO-PAIR COMBOS (bottom row) =====
   // N + M = () with cursor inside
   // M + , = {} with cursor inside
   // , + . = [] with cursor inside
   // . + / = <> with cursor inside
   // K + , = "" with cursor inside
   // J + M = '' with cursor inside

   //  ===== ONE-SHOT MODIFIER COMBOS (top row, GACS order) =====
   //  Left hand
   // Q + W = One-shot GUI
   // W + E = One-shot Alt
   // E + R = One-shot Ctrl
   // R + T = One-shot Shift
   //  Right hand
   // Y + U = One-shot Shift
   // U + I = One-shot Ctrl
   // I + O = One-shot Alt
   // O + P = One-shot GUI

   // ===== LAYER SWITCHING COMBOS =====
   // Universal escape hatch
   // Q + W + E = Return to BASE (from anywhere)

   // From BASE
   // A + S + D = Go to GAMING
   // N + M + , = Go to VIM

   // From GAMING
   // Y + U + I = Go to GAMING2
   // H + J + K = Go to ROGUELIKE

   // Return routes (same combos, opposite direction)
   // Y + U + I = Return to GAMING (from GAMING2)
   // H + J + K = Return to GAMING (from ROGUELIKE)
   // N + M + , = Return to BASE (from VIM)
*/
// =====================================================================================
// Main combo section
// =====================================================================================
        // hj ONE_COMBO_TO_RULE_THEM_ALL
        combo_hj_caps_word {
            timeout-ms = <30>;
            // This is a generic default. It MUST be overridden by
            // board-specific keymaps. Example: For J and K on Sofle, this might
            // be <31 32>.
            key-positions = <0 1>;
            bindings = <&better_caps_word>;
            // layer locking, we can adjust this to allow on more layers as needed
            layers = <BASE VIM>;
        };
        combo_yh_num_word {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&num_word LOWER>; // bindings set to 1 (we need 1 arg, ie. add the &num_word AND then 1 arg, which layer to swap to in this case. It should find LOWER if not put the value 2)
            layers = <BASE VIM>;
        };
        combo_jk_esc {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&kp ESC>;
            layers = <BASE VIM>;
        };
        combo_lscln_ent {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&kp RET>;
            layers = <BASE VIM>;
        };
        combo_fg_underscore {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&kp UNDERSCORE>;
            layers = <BASE VIM>;
        };
        combo_vb_minus {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&kp MINUS>;
            layers = <BASE VIM>;
        };
        // mostly useful for quick delete one char when i fuck up placing ()'s or osm(sk) ctrl
        combo_sd_bspc {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&kp BSPC>;
            layers = <BASE VIM>;
        };

        combo_df_tab {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&kp TAB>;
            layers = <BASE VIM>;
        };

        combo_kl_sqt {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&kp SQT>;
            layers = <BASE VIM>;
        };

// =====================================================================================
// Three finger combos, initial ones are for layer swapping, from base to vim
// from gaming to gaming 2
// from gaming to roguelike
// and then escapes from those top layers back down to base ofc, no trapping.
// =====================================================================================
// THE UNIVERSAL ESCAPE HATCH
        combo_return_to_base {
            timeout-ms = <50>;
            key-positions = <0 1 2>;  // QWE
            bindings = <&to 0>;
            layers = <BASE GAMING GAMING2 ROGUELIKE VIM>; // active return to home on base gaming, gaming2, roguelike, vim
        };

// BASE → GAMING (ASD)
        combo_base_to_gaming {
            timeout-ms = <50>;
            key-positions = <0 1 2>;  // ASD
            bindings = <&to GAMING>;
            layers = <BASE>;
        };

// BASE → VIM (NM,)
        combo_base_to_vim {
            timeout-ms = <50>;
            key-positions = <0 1 2>;  // NM,
            bindings = <&to VIM>;
            layers = <BASE>;
        };

// VIM → BASE (NM,) - toggle back
        combo_vim_to_base {
            timeout-ms = <50>;
            key-positions = <0 1 2>;  // NM,
            bindings = <&to BASE>;
            layers = <VIM>;
        };
// GAMING → ROGUELIKE (HJK)
        combo_gaming_to_roguelike {
            timeout-ms = <50>;
            key-positions = <0 1 2>;  // HJK
            bindings = <&to ROGUELIKE>;
            layers = <GAMING>;
        };

// ROGUELIKE → GAMING (HJK) - toggle back
        combo_roguelike_to_gaming {
            timeout-ms = <50>;
            key-positions = <0 1 2>;  // HJK
            bindings = <&to GAMING>;
            layers = <ROGUELIKE>;
        };

// GAMING → GAMING2 (YUI)
        combo_gaming_to_gaming2 {
            timeout-ms = <50>;
            key-positions = <0 1 2>;  // YUI
            bindings = <&to GAMING2>;
            layers = <GAMING>;
        };

// GAMING2 → GAMING (YUI) - toggle back
        combo_gaming2_to_gaming {
            timeout-ms = <50>;
            key-positions = <0 1 2>;  // YUI
            bindings = <&to GAMING>;
            layers = <GAMING2>;
        };
// =====================================================================================
// top row one shot modifier combos
// =====================================================================================
        // Example: N and M keys for parentheses ()
        combo_nm_parens: combo_nm_parens {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&macro_parens>;
            layers = <BASE VIM>;
        };
        // Example: M and , keys for braces {}
        combo_m_comma_braces: combo_m_comma_braces {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&macro_braces>;
            layers = <BASE VIM>;
        };
        // Example: , . keys for brackets []
        combo_comma_dot_brackets: combo_comma_dot_brackets {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&macro_brackets>;
            layers = <BASE VIM>;
        };
        // Example: . / keys for brackets <>
        combo_dot_slash_ltgt: combo_dot_slash_ltgt {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&macro_ltgt>;
            layers = <BASE VIM>;
        };
// Auto pairing quotes as well
        // Double quotes with cursor inside  " "
        combo_k_comma_dquotes: combo_k_comma_dquotes {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&macro_dquotes>;
            layers = <BASE VIM>;
        };
        // Single quotes with cursor inside ' '
        combo_jm_squotes: combo_jm_squotes {
            timeout-ms = <30>;
            key-positions = <0 1>;
            bindings = <&macro_squotes>;
            layers = <BASE VIM>;
        };
// =====================================================================================
// top row one shot modifier combos GACS just like on homerow, just one row up,
// the idea being for roguelike gaming and since im making a RL it would be nice to
// swap to a layer that i can hit hjkl etc. and because of how games and frame rate work
// not have the awkward lack of input because the firmware waits and the frame doesnt proceess
// =====================================================================================
// Left-hand Shift (R+T])
        combo_rt_lshift: combo_rt_lshift {
            timeout-ms = <COMBO_TERM_FAST>;
            require-prior-idle-ms = <100>;
            key-positions = <0 1>;
            bindings = <&skq LSHFT>;
            slow-release;
            layers = <BASE VIM>;
        };
// Left-hand Control (E+R)
        combo_er_lctrl: combo_er_lctrl {
            timeout-ms = <COMBO_TERM_FAST>;
            require-prior-idle-ms = <100>;
            key-positions = <0 1>;
            bindings = <&skq LCTRL>;
            slow-release;
            layers = <BASE VIM>;
        };
// Left-hand Alt (W+E)
        combo_we_lalt: combo_we_lalt {
            timeout-ms = <COMBO_TERM_FAST>;
            require-prior-idle-ms = <100>;
            key-positions = <0 1>;
            bindings = <&skq LALT>;
            slow-release;
            layers = <BASE VIM>;
        };
// Left-hand Super (Q+W)
        combo_qw_lgui: combo_qw_lgui {
            timeout-ms = <COMBO_TERM_FAST>;
            require-prior-idle-ms = <100>;
            key-positions = <0 1>;
            bindings = <&skq LGUI>;
            slow-release;
            layers = <BASE VIM>;
        };
// =====================================================================================
// Right-hand Shift (Y+U])
        combo_yu_rshift: combo_yu_rshift {
            timeout-ms = <COMBO_TERM_FAST>;
            require-prior-idle-ms = <100>;
            key-positions = <0 1>;
            bindings = <&skq RSHFT>;
            slow-release;
            layers = <BASE VIM GAMING>;
        };
// Right-hand Control (U+I)
        combo_ui_rctrl: combo_ui_rctrl {
            timeout-ms = <COMBO_TERM_FAST>;
            require-prior-idle-ms = <100>;
            key-positions = <0 1>;
            bindings = <&skq RCTRL>;
            slow-release;
            layers = <BASE VIM GAMING>;
        };
// Right-hand Alt (I+O)
        combo_io_ralt: combo_io_ralt {
            timeout-ms = <COMBO_TERM_FAST>;
            require-prior-idle-ms = <100>;
            key-positions = <0 1>;
            bindings = <&skq RALT>;
            slow-release;
            layers = <BASE VIM GAMING>;
        };
// Right-hand Super (O+P)
        combo_op_rgui: combo_op_rgui {
            timeout-ms = <COMBO_TERM_FAST>;
            require-prior-idle-ms = <100>;
            key-positions = <0 1>;
            bindings = <&skq RGUI>;
            slow-release;
            layers = <BASE VIM GAMING>;
        };
// =====================================================================================
// end of combos
// =====================================================================================
    };
};
